学习笔记

​	对于不同 GC 的总结：

​		SerialGC：小堆的情况下这个快，随着堆增大，回收时间变长。

​		ParallelGC(default)：实际gc时间比较短，大堆生成对象表现没CMS和G1优秀。

​		ConcMarkSweepGC：会输出很多信息，和理论上讲的CMS步骤类似；标记阶段非常短（老师说：只需要标记第一个Root根），并发标记不STW(Default:1/4线程数)，默认CMS不做内存整理。

​		G1GC：会输出更多信息，会有比较多的阶段，

​	对于同种GC不同堆内存设置的总结：

​			大堆：初始情况下会比较少的进行GC，但随着系统不断运行，达到GC条件后由于要扫描的对象增多，所以一次GC的时间会相应延长。(其实这里就是一个trade-off,在一个临界值之前，调大堆会提升系统的稳定性，防止在业务波峰冲击时击垮系统。)

​			如何选择JVM设置：

​					分配速率：上一次GC之后，与下一次GC开始之前的年轻代使用量之差除以时间；影响Eden区，一般来说新分配的对象都会分配到Eden区，增大Eden区，可以创造更多对象；在同等对象生成速率下，GC的频率会降低，但由于扫描对象增多，每次Minor的GC时间会增加。如果每次GC的对象都是生命周期比较短的对象，那么minorGC的暂停时间不会明显增加（因为如果存留对象少，身为主要耗时的挪对象过程相较之下不会消耗太多时间）。

​					过早提升：可能有些大对象存活时间并不到晋升老年代的阈值，但由于体积或者内存不够同代集体晋升之类的原因晋升到老年代，由于老年代本来设计就不是冲着频繁处理的，这种对象大量的涌进老年代，会导致FullGC很频繁。而这种过早晋升的对象并不会常常被用到，这就是站着内存不做事，让真正需要进老年代的对象难以进入老年代，每次FullGC都可以释放很多空间。这样可以用：1.提升Eden区的大小，减少这种对象冲进老年代的可能。2：减少每次批处理的数量，也能得到类似的效果。

​					主要还是尊重业务方的需求，如果需求一定需要做这种批处理事务，则只能增加堆内存，或者增大年轻代大小，如果都不行的话，就得优化数据结构，减少内存消耗。

​					**让临时数据都尽可能得存放在年轻代，用的次数不是很多的对象、MinorGC的时候能清理掉的对象不要让它去老年代占位置。这样会降低系统的可用性**